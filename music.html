<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>Famicom-like MML in JavaScript</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, sans-serif; line-height: 1.5; padding: 16px; }
    textarea { width: 100%; height: 90px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    .row { display: grid; grid-template-columns: 1fr; gap: 12px; margin-bottom: 16px; }
    @media (min-width: 860px) { .row { grid-template-columns: repeat(2, 1fr); } }
    button { padding: 8px 14px; font-size: 16px; }
    .small { color: #666; font-size: 12px; }
  </style>
</head>
<body>
  <h1>ファミコン風音源 + MML プレイヤー</h1>

  <div class="row">
    <div>
      <h3>Pulse 1</h3>
      <textarea id="mml_p1">T140 O4 L8 V12 @2
C D E F G A B > C
C. R16 C R16 C</textarea>
    </div>
    <div>
      <h3>Pulse 2</h3>
      <textarea id="mml_p2">T140 O3 L8 V10 @1
C E G C > E G < C E</textarea>
    </div>
    <div>
      <h3>Triangle</h3>
      <textarea id="mml_tri">T140 O2 L8 V12
C2 G2 C2 G2</textarea>
    </div>
    <div>
      <h3>Noise</h3>
      <textarea id="mml_noise">T140 L8 V6
R8 R8 C16 C16 C16 R16 C16 R16</textarea>
    </div>
  </div>

  <div>
    <button id="play">Play</button>
    <button id="stop">Stop</button>
    <span class="small">対応: T L O <> CDEFGAB +/- Nnn R . V0-15 @0/1/2（pulse duty）</span>
  </div>

  <script>
    // --- Utility: frequency from note (A4=440, MIDI 69) ---
    function midiToFreq(n) { return 440 * Math.pow(2, (n - 69) / 12); }

    // NES-like note numbers for MML letters with accidentals
    const NOTE_BASE = { C: 0, D: 2, E: 4, F: 5, G: 7, A: 9, B: 11 };

    // Parse a single MML string to event list
    function parseMML(mml) {
      let i = 0;
      const s = mml.replace(/\s+/g, '').toUpperCase();
      let tempo = 120;       // BPM
      let defLen = 4;        // L4 = quarter
      let octave = 4;        // O4
      let volume = 12;       // 0..15
      let duty = 2;          // @2=50% default
      const events = [];     // { type:'note'|'rest'|'ctrl', lengthBeats, midi?, volume?, duty? }

      function readNumber() {
        let start = i;
        while (i < s.length && /[0-9]/.test(s[i])) i++;
        return start === i ? null : parseInt(s.slice(start, i), 10);
      }
      function readDots() {
        let dots = 0;
        while (s[i] === '.') { dots++; i++; }
        return dots;
      }
      function lengthToBeats(lenNum, dots) {
        // lenNum = denominator (e.g., 4 => quarter), default if null
        const d = lenNum || defLen;
        let beats = 4 / d; // 4 beats per whole note
        // dotted: x + x/2 + x/4 ...
        let add = beats / 2;
        for (let k = 0; k < dots; k++) { beats += add; add /= 2; }
        return beats;
      }

      while (i < s.length) {
        const ch = s[i++];
        if (ch === 'T') {
          const v = readNumber(); if (v != null) tempo = Math.max(1, v);
        } else if (ch === 'L') {
          const v = readNumber(); if (v != null) defLen = Math.max(1, v);
        } else if (ch === 'O') {
          const v = readNumber(); if (v != null) octave = v;
        } else if (ch === '<') {
          octave--;
        } else if (ch === '>') {
          octave++;
        } else if (ch === 'V') {
          const v = readNumber(); if (v != null) volume = Math.max(0, Math.min(15, v));
        } else if (ch === '@') {
          const v = readNumber(); if (v != null) duty = Math.max(0, Math.min(2, v));
        } else if (ch === 'R') {
          const len = readNumber();
          const dots = readDots();
          events.push({ type: 'rest', lengthBeats: lengthToBeats(len, dots) });
        } else if (ch === 'N') {
          const num = readNumber();
          if (num == null) continue;
          const len = readNumber();
          const dots = readDots();
          events.push({ type: 'note', midi: num, lengthBeats: lengthToBeats(len, dots), volume, duty });
        } else if (ch in NOTE_BASE) {
          let semitone = NOTE_BASE[ch];
          // accidental
          if (s[i] === '+' || s[i] === '#') { semitone += 1; i++; }
          else if (s[i] === '-') { semitone -= 1; i++; }
          const len = readNumber();
          const dots = readDots();
          const midi = 12 * (octave + 1) + semitone; // C4=60 when O4
          events.push({ type: 'note', midi, lengthBeats: lengthToBeats(len, dots), volume, duty });
        } else {
          // ignore unknown
        }
      }
      return { tempo, events };
    }

    // Build a PeriodicWave for pulse with duty 12.5/25/50%
    function createPulseWave(context, duty) {
      // duty: 0 -> 12.5%, 1 -> 25%, 2 -> 50%
      const d = [0.125, 0.25, 0.5][duty] ?? 0.5;
      // Fourier series for pulse:
      // a_k = (2/dk) * sin(k*pi*d), b_k = 0 for odd wave? We can use real-only
      const harmonics = 64;
      const real = new Float32Array(harmonics + 1);
      const imag = new Float32Array(harmonics + 1);
      real[0] = 0; imag[0] = 0;
      for (let k = 1; k <= harmonics; k++) {
        // From rectangular wave with duty d
        const a = (Math.sin(Math.PI * k * d)) / (k);
        // Scale to approximate NES-ish timbre
        real[k] = 2 * a;
        imag[k] = 0;
      }
      return context.createPeriodicWave(real, imag, { disableNormalization: false });
    }

    // Noise buffer (white-ish). For simplicity we use short looping buffer.
    function createNoiseBuffer(context, durationSec = 1.0) {
      const rate = context.sampleRate;
      const length = Math.floor(durationSec * rate);
      const buffer = context.createBuffer(1, length, rate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < length; i++) {
        data[i] = (Math.random() * 2 - 1) * 0.9;
      }
      return buffer;
    }

    // Schedule one track given events and voice type
    function scheduleTrack(context, when, trackType, parsed, master, pulseWaveCache) {
      const secondsPerBeat = 60 / parsed.tempo;
      let t = when;

      for (const ev of parsed.events) {
        const dur = ev.lengthBeats * secondsPerBeat;

        if (ev.type === 'rest') {
          t += dur;
          continue;
        }

        const vol = (ev.volume ?? 12) / 15; // 0..1
        const freq = midiToFreq(ev.midi);

        if (trackType === 'pulse') {
          const osc = context.createOscillator();
          osc.setPeriodicWave(pulseWaveCache[ev.duty ?? 2]);

          const gain = context.createGain();
          gain.gain.setValueAtTime(0, t);
          // Simple envelope: quick attack, small decay to avoid clicks
          gain.gain.linearRampToValueAtTime(vol, t + 0.004);
          gain.gain.setTargetAtTime(vol * 0.9, t + 0.05, 0.03);
          gain.gain.setValueAtTime(vol * 0.9, t + Math.max(0, dur - 0.02));
          gain.gain.linearRampToValueAtTime(0.0001, t + dur);

          osc.frequency.setValueAtTime(freq, t);
          osc.connect(gain).connect(master);
          osc.start(t);
          osc.stop(t + dur + 0.01);
        } else if (trackType === 'triangle') {
          const osc = context.createOscillator();
          const gain = context.createGain();
          // NES triangleは音量一定だが、全体バランスのため少しだけスケール
          const triVol = Math.min(vol, 0.7);

          osc.type = 'triangle';
          osc.frequency.setValueAtTime(freq, t);

          gain.gain.setValueAtTime(0, t);
          gain.gain.linearRampToValueAtTime(triVol, t + 0.004);
          gain.gain.setValueAtTime(triVol, t + Math.max(0, dur - 0.01));
          gain.gain.linearRampToValueAtTime(0.0001, t + dur);

          osc.connect(gain).connect(master);
          osc.start(t);
          osc.stop(t + dur + 0.01);
        } else if (trackType === 'noise') {
          const src = context.createBufferSource();
          src.buffer = createNoiseBuffer(context, 0.25);
          src.loop = true;

          const gain = context.createGain();
          const noiseVol = Math.min(vol, 0.6);

          gain.gain.setValueAtTime(0, t);
          gain.gain.linearRampToValueAtTime(noiseVol, t + 0.003);
          gain.gain.setValueAtTime(noiseVol, t + Math.max(0, dur - 0.01));
          gain.gain.linearRampToValueAtTime(0.0001, t + dur);

          src.connect(gain).connect(master);
          src.start(t);
          src.stop(t + dur + 0.02);
        }

        t += dur;
      }
      return t;
    }

    // Global audio state
    let audioCtx = null;
    let masterGain = null;
    let playingNodes = new Set();

    function stopAll() {
      if (!audioCtx) return;
      try { masterGain.disconnect(); } catch {}
      for (const n of playingNodes) { try { n.disconnect(); } catch {} }
      playingNodes.clear();
      audioCtx.close();
      audioCtx = null;
    }

    document.getElementById('play').addEventListener('click', async () => {
      stopAll();
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.6;
      masterGain.connect(audioCtx.destination);

      const now = audioCtx.currentTime + 0.05;

      const pulseWaves = [
        createPulseWave(audioCtx, 0),
        createPulseWave(audioCtx, 1),
        createPulseWave(audioCtx, 2),
      ];

      const mmls = {
        p1: document.getElementById('mml_p1').value,
        p2: document.getElementById('mml_p2').value,
        tri: document.getElementById('mml_tri').value,
        noi: document.getElementById('mml_noise').value,
      };

      const p1 = parseMML(mmls.p1);
      const p2 = parseMML(mmls.p2);
      const tri = parseMML(mmls.tri);
      const noi = parseMML(mmls.noi);

      // 各トラックを並列スケジューリング
      scheduleTrack(audioCtx, now, 'pulse', p1, masterGain, pulseWaves);
      scheduleTrack(audioCtx, now, 'pulse', p2, masterGain, pulseWaves);
      scheduleTrack(audioCtx, now, 'triangle', tri, masterGain, pulseWaves);
      scheduleTrack(audioCtx, now, 'noise', noi, masterGain, pulseWaves);
    });

    document.getElementById('stop').addEventListener('click', stopAll);
  </script>
</body>
</html>
